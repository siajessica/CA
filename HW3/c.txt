.globl __start

.text
__start:
    # Read first operand in x5
    addi x10 x0 5
    ecall
    add x5 x10 x0
    
    jal x1 t_rec
    jal x0 exit
    
#arg in x10, return in x11
t_rec:
    #setup
    addi x2 x2 -8 #reserve stack
    sw x1 0(x2) #save ra
    addi x31 x0 2 #constant
    add x5 x10 x0 #save n
    
    #trivial case
    blt x10 x31 t_one #if n<2
    
    #count T(n-100)
    addi x10 x10 -100 #x10 = n-100
    jal x1 t_rec #T(n-100)
    sw x11 4(x2) #save T(n-100) in stack
    
    #count T(n/2)
    add x10 x5 x0 #x10 = n
    div x10 x10 x31 #x10 = n/2
    jal x1 t_rec #T(n/2)
    
    #Count ret
    mul x11 x11 x31 #ret = 2*T(n/2)
    addi x11 x11 5 #ret = ret + 5
    lw x30 4(x2) #x30 = T(n-100)
    add x11 x11 x30
    jal x0 free
    
t_one:
    addi x11 x0 1
    jal x0 free
    
free:
    lw x1 0(x2) #restore ra
    addi x2 x2 8 #free ra
    jalr x0 0(x1) #return
  
exit:
    # Output the result
    addi x10 x0 1
    ecall
    
    # Exit program(necessary)
    addi x10 x0 10
    ecall